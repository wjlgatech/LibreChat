<!DOCTYPE html>
<html>
<head>
  <title>Simple WebRTC Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
    }
    .log {
      background: #f0f0f0;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      cursor: pointer;
    }
    .success { color: green; }
    .error { color: red; }
    .info { color: blue; }
  </style>
</head>
<body>
  <h1>Simple WebRTC Voice AI Test</h1>
  
  <div>
    <button onclick="testConnection()">1. Test Connection</button>
    <button onclick="testRouterCapabilities()">2. Test Router Capabilities</button>
    <button onclick="testVoiceSession()">3. Test Voice Session</button>
  </div>
  
  <div id="log" class="log"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mediasoup-client@3/lib/mediasoup-client.js"></script>
  
  <script>
    let socket;
    let device;
    
    function log(message, type = 'info') {
      const logDiv = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = type;
      const timestamp = new Date().toLocaleTimeString();
      entry.textContent = `[${timestamp}] ${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }
    
    async function testConnection() {
      try {
        log('Testing Socket.IO connection...');
        
        if (socket && socket.connected) {
          log('Already connected!', 'success');
          return;
        }
        
        socket = io('http://localhost:3000', {
          transports: ['websocket']
        });
        
        socket.on('connect', () => {
          log('Connected to server! Socket ID: ' + socket.id, 'success');
        });
        
        socket.on('disconnect', () => {
          log('Disconnected from server', 'error');
        });
        
        socket.on('error', (error) => {
          log('Socket error: ' + error, 'error');
        });
        
        // Wait for connection
        await new Promise((resolve) => {
          if (socket.connected) {
            resolve();
          } else {
            socket.once('connect', resolve);
          }
        });
        
      } catch (error) {
        log('Connection error: ' + error.message, 'error');
      }
    }
    
    async function testRouterCapabilities() {
      try {
        if (!socket || !socket.connected) {
          log('Not connected! Please test connection first.', 'error');
          return;
        }
        
        log('Testing router capabilities...');
        
        const capabilities = await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('Router capabilities timeout'));
          }, 5000);
          
          socket.emit('get-router-rtp-capabilities');
          log('Sent get-router-rtp-capabilities event');
          
          socket.once('router-rtp-capabilities', (caps) => {
            clearTimeout(timeout);
            log('Received router-rtp-capabilities event', 'success');
            resolve(caps);
          });
        });
        
        log('Router capabilities received: ' + JSON.stringify(capabilities, null, 2), 'success');
        
        // Initialize device
        log('Initializing MediaSoup device...');
        
        // Try different ways to access the library
        let DeviceClass;
        if (typeof mediasoupClient !== 'undefined' && mediasoupClient.Device) {
          DeviceClass = mediasoupClient.Device;
          log('Using mediasoupClient.Device');
        } else if (window.mediasoupClient && window.mediasoupClient.Device) {
          DeviceClass = window.mediasoupClient.Device;
          log('Using window.mediasoupClient.Device');
        } else if (window.mediasoup && window.mediasoup.Device) {
          DeviceClass = window.mediasoup.Device;
          log('Using window.mediasoup.Device');
        } else {
          // Last resort - check if it's loaded differently
          log('Available in window: ' + Object.keys(window).filter(k => k.includes('mediasoup')).join(', '));
          throw new Error('MediaSoup client library not found. Please check if it loaded correctly.');
        }
        
        device = new DeviceClass();
        await device.load({ routerRtpCapabilities: capabilities });
        log('Device loaded successfully!', 'success');
        
      } catch (error) {
        log('Router capabilities error: ' + error.message, 'error');
      }
    }
    
    async function testVoiceSession() {
      try {
        if (!socket || !socket.connected) {
          log('Not connected! Please test connection first.', 'error');
          return;
        }
        
        if (!device) {
          log('Device not initialized! Please test router capabilities first.', 'error');
          return;
        }
        
        log('Starting voice session...');
        
        // Get user media
        log('Requesting microphone access...');
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: true 
        });
        log('Got microphone access', 'success');
        
        // Start voice session
        socket.emit('start-voice-session', {
          voice: 'alloy',
          language: 'en',
          sttProvider: 'deepgram',
          ttsProvider: 'openai',
          llmModel: 'gpt-4'
        });
        log('Sent start-voice-session event');
        
        // Wait for transport
        const transportInfo = await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('Transport creation timeout'));
          }, 10000);
          
          socket.once('transport-created', (info) => {
            clearTimeout(timeout);
            log('Received transport-created event', 'success');
            resolve(info);
          });
        });
        
        log('Transport info: ' + JSON.stringify(transportInfo, null, 2), 'success');
        
        // Create transport
        const transport = device.createSendTransport(transportInfo);
        log('Created send transport', 'success');
        
        // Set up transport events
        transport.on('connect', async ({ dtlsParameters }, callback, errback) => {
          try {
            log('Transport connect event');
            socket.emit('connect-transport', { dtlsParameters });
            socket.once('transport-connected', () => {
              log('Transport connected', 'success');
              callback();
            });
          } catch (error) {
            errback(error);
          }
        });
        
        transport.on('produce', async ({ kind, rtpParameters }, callback, errback) => {
          try {
            log('Transport produce event');
            socket.emit('produce', { kind, rtpParameters });
            socket.once('produced', ({ id }) => {
              log('Producer created with ID: ' + id, 'success');
              callback({ id });
            });
          } catch (error) {
            errback(error);
          }
        });
        
        // Create producer
        const track = stream.getAudioTracks()[0];
        const producer = await transport.produce({ track });
        log('Audio producer created successfully!', 'success');
        
      } catch (error) {
        log('Voice session error: ' + error.message, 'error');
      }
    }
    
    // Test on page load
    window.onload = () => {
      log('Simple WebRTC test ready');
      
      // Check what's available
      log('Checking available libraries...');
      if (typeof mediasoupClient !== 'undefined') {
        log('mediasoupClient is available', 'success');
      }
      if (window.mediasoupClient) {
        log('window.mediasoupClient is available', 'success');
      }
      if (window.mediasoup) {
        log('window.mediasoup is available', 'success');
      }
    };
  </script>
</body>
</html>